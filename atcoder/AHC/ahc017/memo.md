# AHC
## Input
A undirected graph G = (V, E, w), D \in \mathbb{N}, K  \in \mathbb{N}
(|V| = N, |E| = M)

* Gはplanar, 2-edge-connected


## Asked

$\mathrm{dist}(u, v)$ を $G$ における $u$ から $v$ の最短経路長, $mathrm{dist}_k(u, v)$ を $G_k = (V, E \setminus E_k, w)$ における $u$ から $v$ の最短経路長としたとき,

$$f = \sum_{u \ne v} \mathrm{dist}(u, v)$$
として, $k$ 日目の不満度を
$$ f_k = \sum_{u \ne v} \mathrm{dist}_k(u, v) - f $$
とする.

$$F(\pi) = \mathrm{round}(10^3 \times \frac{1}{D} \sum_{k=1}^{D} f_k)$$

を最小化するEのサイズK以下のD-分割 $\pi$ を求める

## Score:
各ケースについて $\mathrm{round}(min(F_i(\pi))/F_{me}(\pi) * 10^9)$ の相対評価を足したもの

* 小さいインスタンスは厳密解を求めたほうが良い.

## まとめ
### 事実
* 平面2-辺連結. N <= 1000に対して, M <= 3000なので, 割と疎なグラフ.
* サイズ制約のみ, 分割なので, 一度実行可能な分割を作ってあげて, 同じ数だけ辺を入れ替えすれは状態遷移できる

### やったこと
#### 1. 順番にK個まで割り当てる
* Score: 143,408,182,139	

#### 2. ランダムかつサイズ均等にD分割
* Score: 35,750,100,639
* よくなる* 順番に割り当てるよりランダムに割り当てれば割と良い解が出る(開始5hくらいで67位/217人)
  * とりあえず初期解はこれで良さそう

#### 3. 焼きなましする
* 初期解のコスト計算が重い
  * 何も枝を分割しない時の全点対最短経路長はダイクストラ法で O(N * M * log N) 時間かかる
    * N <= 1000, M <= 3000なので、大体 3 * 10^6 くらい。許容範囲だと思う.
  * 一度分割を決めた時の不満度(全点対最短経路)の計算は ダイクストラ法で O(D * N * M * log N) 時間かかる
    * D <= 30 なので, 9 * 10^7 ~ 10^8 くらい. もっと高速化できないか

* 一度分割を決めた時の不満度(全点対最短経路)の計算は ダイクストラ法で O(N * M * log N) 時間かかる
  * N<=1000なので, 結構重い. 一度計算したらあとは流用できないか
    * 同数辺の入れ替えなら、入れ替えしたグループだけ更新すれば良い. 初期解の正確なコスト計算は諦めて、局所的に差分計算すれば1回の探索を2秒程度で実行できる（2回くらい探索できる）

#### 4. 焼きなましの遷移/差分計算の高速化
* 更新された状態をいくつか見てみたら、到達不能になった場合が一番コストが大きくなる。そのため、せめて到達不可能なパターンは避けて、平均的な最短路長が短くなってくれれば良い
  * 到達不可能性を評価するには、適当な頂点を始点として全点への最短経路長を調べれば良い。
  * そもそも平均的に良くなっていれば嬉しいのなら、全点を調べずに、適当な頂点でサンプリングしてみるのが良いのでは
    * 5頂点くらいでも十分ぽい



### 考えていること（未対応. 重要度順に並べておく）
* 遷移の考え方
  * うまくいっていないグラフを見ると、特定の頂点(次数3とか)に接続する全辺が1日で工事されたりしている. なんとかしたいね

* スコア差分計算の高速化
  * 枝uvを消す操作:
    + 最短路木においてuvが使われていない -> 影響ないのでその始点sからの最短路長は変化しない
    + 最短路木においてuvが使われている -> uもしくはvの部分木に含まれる頂点が影響するので, 最短路の再計算が必要

  * 枝uvを増やす操作: 始点s, 終点tとして, 既に得られているs-t最短路長と, dist(s, u) + w(uv) + dist(v, t), dist(s, v) + w(uv) + dist(u, t) を比較して一番小さいもの
    * s-tペアにつき定数回の比較操作で完結する

* 一度ダイクストラを回すと、最短路木が得られる. これは始点を根とする全域木になっているので、M-(N-1)の枝はまとめて工事したほうが良い. 残りはランダムに割り振ってみる？
  * ある頂点だけで見た時の話. でも、この考え方で枝の重要度（幾つの最短路で使われているか）を使って重みづけできないか？
  * 更新時の差分評価高速化に使えそうなので別で項目作る

* 初期解のコスト計算が重い
  * 何も枝を分割しない時の全点対最短経路長はダイクストラ法で O(N * M * log N) 時間かかる
    * N <= 1000, M <= 3000なので、大体 3 * 10^6 くらい。許容範囲だと思う. OK
* 一度分割を決めた時の不満度(全点対最短経路)の計算は ダイクストラ法で O(D * N * M * log N) 時間かかる -> __計算しない. 差分だけ評価する__ OK.
  * D <= 30 なので, 9 * 10^7 ~ 10^8 くらい. もっと高速化できないか?
  * グループを固定した時, 使えない枝に接続する頂点は 高々 2*K 個 <= 2* 2 * ceil(M/D) = 4 * M/D. これが D * N より小さいなら隣接頂点だけやれば良い. 明らかに 2 * K <= Nなので, D*Nより小さい. 2*K 頂点から各点への最短路木にグループ内の辺が使われていなければ, dist_k(u, v) = dist(u, v) になる (グループ内の頂点に接続する辺はその頂点から各点に向かう最短路長に影響しないので)
  * というか既に最短経路長計算した点を始点にするなら, 他への最短経路長はそれを再利用したほうが良い
  * 大元のグラフの最短路木を全点に対して持つと、 O(N * N) なので 大体10^6 バイト = 1MBで持てる. 


* 小さいインスタンスは厳密解を求めたほうが良い?
  * どうやって？全探索すると D^M. 最小ケースでも 5^500なのできつい. 時間中に終わるサイズを見積もりたい

* 最短経路に影響ない枝はまとめて最初に切ったほうが良い？
1. 一度N回ダイクストラ実行して各頂点から全点への最短経路を調べて、使う枝にマーキング(ヒープ使って $O(|V| * |E| \log |V|)$　
2. 1日目(もしくはできる限り)は使わない枝をまとめて工事したほうが良い
3. 残りでランダムにする、とか？

### ある程度結論出たもの
* 初期解のコスト計算が重い -> 工事しない時の最短路長は許容範囲.
  * 何も枝を分割しない時の全点対最短経路長はダイクストラ法で O(N * M * log N) 時間かかる
    * N <= 1000, M <= 3000なので、大体 3 * 10^6 くらい。許容範囲だと思う. -> 500msecくらい

* 一度分割を決めた時の不満度(全点対最短経路)の計算は ダイクストラ法で O(D * N * M * log N) 時間かかる -> __計算しない. 差分だけ評価する__ OK.
  * D <= 30 なので, 9 * 10^7 ~ 10^8 くらい. もっと高速化できないか?
  * グループを固定した時, 使えない枝に接続する頂点は 高々 2*K 個 <= 2* 2 * ceil(M/D) = 4 * M/D. これが D * N より小さいなら隣接頂点だけやれば良い. 明らかに 2 * K <= Nなので, D*Nより小さい. 2*K 頂点から各点への最短路木にグループ内の辺が使われていなければ, dist_k(u, v) = dist(u, v) になる (グループ内の頂点に接続する辺はその頂点から各点に向かう最短路長に影響しないので)
  * というか既に最短経路長計算した点を始点にするなら, 他への最短経路長はそれを再利用したほうが良い
  * 大元のグラフの最短路木を全点に対して持つと、 O(N * N) なので 大体10^6 バイト = 1MBで持てる. 


### 参考
* [焼きなましについて](https://gasin.hatenadiary.jp/entry/2019/09/03/162613)
  * 使っているテンプレートはここを参照している
* [焼きなましについて2](https://shindannin.hatenadiary.com/entry/20121224/1356364040)
  * 何かヒントないかな